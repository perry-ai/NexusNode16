# JavaScript基础知识

是一种广泛应用于网页开发的脚本语言，具有灵活的语法和动态类型。以下是 JavaScript 核心概念的详细介绍：

### 一、基础语法

#### 1. **变量声明**

- **`var`**（旧方式，存在变量提升和作用域问题）：
  ```javascript
  var x = 10
  ```
- **`let`**（块级作用域，推荐使用）：
  ```javascript
  let name = 'Alice'
  ```
- **`const`**（声明常量，不可重新赋值）：

  ```javascript
  const PI = 3.14
  ```

- **作用域概念**：

  - 函数作用域（Function Scope）

    - **定义**：  
      使用 `var` 声明的变量，其作用域是 **整个函数体内部**（或全局作用域），与代码块（如 `{}`）无关。
    - **特点**：
      1. **变量提升（Hoisting）**：`var` 声明的变量会提升到函数顶部（仅声明，不赋值）。
      2. **无视代码块**：即使在 `if`、`for` 等代码块中声明，变量依然属于函数作用域。
    - **示例**：
      ```javascript
      function example() {
        if (true) {
          var a = 10 // 作用域是整个函数体
        }
        console.log(a) // 输出 10（变量泄漏到函数作用域）
      }
      example()
      ```

  - 块级作用域（Block Scope）

    - **定义**：  
      使用 `let` 或 `const` 声明的变量，其作用域是 **最近的代码块（`{}`）内部**（如 `if`、`for`、`while` 等）。
    - **特点**：

      1. **无变量提升**：`let`/`const` 不会提升到块顶部，在声明前访问会报错（暂时性死区）。
      2. **严格隔离**：变量仅在代码块内有效，外部无法访问。

    - **示例**：
      ```javascript
      function example() {
        if (true) {
          let b = 20 // 作用域是当前代码块
          const c = 30
        }
        console.log(b) // 报错：b is not defined
        console.log(c) // 报错：c is not defined
      }
      example()
      ```

  - 函数作用域和块级作用域区别:
    | 特性 | 函数作用域（`var`） | 块级作用域（`let`/`const`） |
    | ------------ | -------------------------- | ---------------------------------- |
    | 作用域范围 | 整个函数或全局作用域 | 最近的代码块（`{}`）内部 |
    | 变量提升 | 是（声明提升，赋值不提升） | 否（存在暂时性死区） |
    | 重复声明 | 允许（覆盖原值） | 不允许（语法错误） |
    | 循环中的行为 | 索引变量泄漏到外部 | 每次迭代独立作用域（解决闭包问题） |

  - 经典案例对比

    - **循环中的变量泄漏**:

      ```javascript
      // var 导致变量泄漏到函数作用域
      for (var i = 0; i < 3; i++) {
        setTimeout(() => console.log(i)) // 输出 3, 3, 3
      }

      // let 每次循环生成独立的块级作用域
      for (let j = 0; j < 3; j++) {
        setTimeout(() => console.log(j)) // 输出 0, 1, 2
      }
      ```

  - 变量提升（Hoisting）

    - **定义**
      JavaScript 引擎在代码执行前会扫描代码，将变量和函数的声明提升到当前作用域的顶部。但**初始化不会提升**。

    - **`var` 的变量提升**

      - **行为**：使用 `var` 声明的变量会被提升到函数/全局作用域的顶部，但值为 `undefined`。
      - **示例**：
        ```javascript
        console.log(a) // 输出 undefined（变量已声明但未赋值）
        var a = 10
        console.log(a) // 输出 10
        ```
        实际执行顺序等价于：
        ```javascript
        var a // 声明提升
        console.log(a) // undefined
        a = 10 // 初始化保留在原位
        console.log(a) // 10
        ```

    - **函数声明提升**

      - **函数声明**整体提升，包括函数体：
        ```javascript
        sayHello() // 输出 "Hello"（函数声明被提升）
        function sayHello() {
          console.log('Hello')
        }
        ```
      - **函数表达式**不会提升（如 `var func = function() {}`）。

    - **`let` 和 `const` 没有变量提升**

      - 使用 `let` 或 `const` 声明的变量不会被提升，如果在声明前访问会触发 **暂时死区** 错误。

  - 暂时死区（Temporal Dead Zone, TDZ）

    - **定义**

      在代码块内，从作用域开始到变量声明语句之间的区域称为暂时死区。在此区域访问变量会触发 `ReferenceError`。

    - **原因**

      - `let` 和 `const` 的声明虽然被 JavaScript 引擎识别，但在声明语句执行前不可访问。
      - 这是为了强制开发者遵循“先声明，后使用”的规范。

    - **示例**

      ```javascript
      console.log(x) // 报错：Cannot access 'x' before initialization
      let x = 10

      // TDZ 示例
      {
        console.log(y) // 报错：y is not defined（进入块级作用域后，y 的 TDZ 开始）
        let y = 20 // TDZ 结束
      }
      ```

#### 2. **注释**

- 单行注释：`// 这是注释`
- 多行注释：`/* 多行注释 */`

#### 3. **分号**

- 分号可选，但建议显式添加以避免自动插入的潜在问题：
  ```javascript
  let a = 1
  ```

#### 4. **大小写敏感**

- `myVar` 和 `myvar` 是不同的变量。

---

### 二、数据结构

#### 1. **原始类型（Primitive Types）**

- **`number`**：整数或浮点数，如 `42` 或 `3.14`
- **`string`**：文本，用单引号或双引号包裹，如 `"Hello"`
- **`boolean`**：`true` 或 `false`
- **`null`**：表示空值（需显式赋值）
- **`undefined`**：变量未初始化时的默认值
- **`symbol`**（ES6+）：唯一标识符，如 `Symbol('id')`

#### 2. **对象类型（Object Types）**

- **`Object`**：键值对的集合：
  ```javascript
  let person = { name: 'Bob', age: 30 }
  ```
- **`Array`**：有序列表：
  ```javascript
  let numbers = [1, 2, 3]
  ```
- **`Map`**（ES6+）：键值对的集合（键可为任意类型）：
  ```javascript
  let map = new Map()
  map.set('key', 'value')
  ```
- **`Set`**（ES6+）：唯一值的集合：
  ```javascript
  let set = new Set([1, 2, 3])
  ```

#### 3. **类型检测**

- `typeof`：检测原始类型，如 `typeof "str"` 返回 `"string"`
- `instanceof`：检测对象类型，如 `[] instanceof Array` 返回 `true`

---

### 三、函数与方法

#### 1. **函数定义**

- **函数声明**：
  ```javascript
  function add(a, b) {
    return a + b
  }
  ```
- **函数表达式**：
  ```javascript
  const multiply = function (a, b) {
    return a * b
  }
  ```
- **箭头函数**（ES6+，无自己的 `this`）：
  ```javascript
  const square = (x) => x * x
  ```

#### 2. **参数处理**

- **默认参数**：
  ```javascript
  function greet(name = 'Guest') {
    console.log(`Hello, ${name}`)
  }
  ```
- **剩余参数（Rest Parameters）**：
  ```javascript
  function sum(...numbers) {
    return numbers.reduce((acc, num) => acc + num, 0)
  }
  ```

#### 3. **方法**

- 对象中的函数称为方法：
  ```javascript
  const calculator = {
    add: function (a, b) {
      return a + b
    },
    // ES6简写
    subtract(a, b) {
      return a - b
    },
  }
  ```

#### 4. **高阶函数**

- 接受函数作为参数或返回函数：
  ```javascript
  const numbers = [1, 2, 3]
  const doubled = numbers.map((num) => num * 2) // [2, 4, 6]
  ```

---

### 四、控制语句

#### 1. **条件语句**

- **`if-else`**：
  ```javascript
  if (age >= 18) {
    console.log('Adult')
  } else {
    console.log('Minor')
  }
  ```
- **`switch`**：
  ```javascript
  switch (day) {
    case 'Monday':
      console.log('Work day')
      break
    default:
      console.log('Unknown day')
  }
  ```

#### 2. **循环语句**

- **`for`**：
  ```javascript
  for (let i = 0; i < 5; i++) {
    console.log(i)
  }
  ```
- **`while`**：
  ```javascript
  let i = 0
  while (i < 5) {
    console.log(i)
    i++
  }
  ```
- **`for...of`**（遍历可迭代对象，如数组）：
  ```javascript
  for (const num of [1, 2, 3]) {
    console.log(num)
  }
  ```
- **`for...in`**（遍历对象属性）：
  ```javascript
  const obj = { a: 1, b: 2 }
  for (const key in obj) {
    console.log(key, obj[key]) // 输出 "a 1", "b 2"
  }
  ```

#### 3. **流程控制**

- **`break`**：退出循环
- **`continue`**：跳过当前循环迭代
- **`return`**：退出函数并返回值

---

### 五、使用方式

#### 1. **浏览器环境**

- 通过 `<script>` 标签嵌入 HTML：
  ```html
  <script>
    console.log('Hello from inline JS!')
  </script>
  ```
- 外部文件引入：
  ```html
  <script src="app.js"></script>
  ```

#### 2. **Node.js 环境**

- 通过命令行运行：`node app.js`

#### 3. **DOM 操作**

- 操作网页元素：
  ```javascript
  document.getElementById('myButton').addEventListener('click', () => {
    alert('Button clicked!')
  })
  ```

---

### 六、注意事项

1. **作用域**：`var` 是函数作用域，`let/const` 是块级作用域。
2. **严格模式**：使用 `"use strict";` 启用更严格的语法检查。
3. **深拷贝与浅拷贝**：对象和数组是引用传递，需用 `JSON.parse(JSON.stringify(obj))` 或库函数实现深拷贝。
4. JavaScript 的灵活性和丰富的生态系统使其成为现代 Web 开发的核心语言。深入学习可进一步探索闭包、原型链、Promise、异步编程等高级主题。

### 类与闭包

- 在 JavaScript 中，使用 **闭包** 和 **类（Class）** 都可以实现模块化和私有变量的封装，但它们的设计理念和适用场景有所不同。以下是两者的对比和选择依据：

- **闭包 vs 类**：如何实现私有变量？

  - **闭包的实现方式**
    通过函数作用域隐藏变量，返回一个访问这些变量的公共接口：

        ```javascript
        function createCounter() {
        let count = 0 // 私有变量
        return {
            increment() {
            count++
            },
            getCount() {
            return count
            },
        }
        }

        const counter = createCounter()
        counter.increment()
        console.log(counter.getCount()) // 1
        // 无法直接访问 count
        ```

  - **类的实现方式**
    通过 ES6+ 的私有字段（`#` 前缀）或约定（如 `_` 前缀）实现私有变量：

    ```javascript
    class Counter {
      #count = 0 // ES6+ 私有字段（真正私有）

      increment() {
        this.#count++
      }
      getCount() {
        return this.#count
      }
    }

    const counter = new Counter()
    counter.increment()
    console.log(counter.getCount()) // 1
    // counter.#count 会报错（私有字段不可访问）
    ```

- **为什么选择闭包？**

  - **兼容性更强**

    - **闭包** 可在任何 JavaScript 环境（包括 ES5）中工作。
    - **类的私有字段**（`#`）需要 ES2022+ 支持，旧环境（如 IE）不兼容。

  - **更灵活的封装**

    - **闭包** 可以动态生成多个独立实例，每个实例有自己的私有状态：
      ```javascript
      const counter1 = createCounter()
      const counter2 = createCounter()
      counter1.increment()
      console.log(counter1.getCount()) // 1
      console.log(counter2.getCount()) // 0（独立状态）
      ```
    - **类** 的实例默认共享方法（通过原型链），但私有字段是实例级别的：

      ```javascript
      const counter1 = new Counter()
      const counter2 = new Counter()
      counter1.increment()
      console.log(counter1.getCount()) // 1
      console.log(counter2.getCount()) // 0（私有字段独立）
      ```

  - **函数式编程范式**

    - 闭包更符合函数式编程的“纯函数”和“无副作用”思想，适合组合和高阶函数。
    - 类是面向对象编程（OOP）的产物，适合封装继承和多态。

  - **轻量级场景**

    - 如果只需简单封装状态，闭包可能比类更简洁，无需 `new` 和 `this`：

      ```javascript
      // 闭包
      const logger = (() => {
        let logs = []
        return { log: (msg) => logs.push(msg), getLogs: () => logs }
      })()

      // 类
      class Logger {
        #logs = []
        log(msg) {
          this.#logs.push(msg)
        }
        getLogs() {
          return this.#logs
        }
      }
      const logger = new Logger()
      ```

- **为什么选择类？**

  - **清晰的面向对象结构**

    - 类提供明确的语法定义构造函数、方法、继承关系，代码可读性更强。
    - 适合复杂业务逻辑的场景（如游戏角色、UI 组件）。

  - **内置的继承机制**

    - 类支持 `extends` 和 `super`，方便实现继承和多态：

      ```javascript
      class Animal {
        constructor(name) {
          this.name = name
        }
        speak() {
          console.log(`${this.name} makes a noise`)
        }
      }

      class Dog extends Animal {
        speak() {
          console.log(`${this.name} barks`)
        }
      }

      const dog = new Dog('Rex')
      dog.speak() // "Rex barks"
      ```

  - **现代语言特性支持**

    - 私有字段（`#`）、静态方法、getter/setter 等特性更符合现代开发需求：
      ```javascript
      class User {
        #password // 私有字段
        constructor(username, password) {
          this.username = username
          this.#password = password
        }
        validatePassword(input) {
          return input === this.#password
        }
      }
      ```

  - **工具链和生态支持**

    - 类在 TypeScript、React 等框架中被广泛使用，与装饰器（Decorators）、类型系统等结合更紧密。

- **核心选择依据**
  | **场景** | **闭包** | **类** |
  |-------------------------|-----------------------------------|---------------------------------|
  | **兼容性要求** | 需要支持旧环境（如 ES5） | 现代浏览器或 Node.js 环境 |
  | **编程范式** | 函数式编程、轻量封装 | 面向对象编程、复杂业务逻辑 |
  | **私有变量实现** | 函数作用域隔离 | 私有字段（`#`）或约定（`_`） |
  | **代码结构** | 灵活、无强制模板 | 清晰、有固定模板（构造函数等） |
  | **性能** | 每个实例独立函数，可能占用更多内存 | 方法在原型链共享，内存更高效 |

- **现代开发中的平衡**

  - **模块化：优先用类**

    - 使用类的私有字段和模块化语法（ES Modules）更符合现代标准：

      ```javascript
      // counter.js
      export class Counter {
        #count = 0
        increment() {
          this.#count++
        }
        getCount() {
          return this.#count
        }
      }

      // app.js
      import { Counter } from './counter.js'
      const counter = new Counter()
      ```

  - **简单封装：闭包仍有优势**

    - 工具函数、一次性状态管理：

      ```javascript
      // 闭包实现单例模式
      const singleton = (() => {
        let instance
        return () => {
          if (!instance) instance = new HeavyObject()
          return instance
        }
      })()
      ```

- **混合使用**

  - 在类中利用闭包实现更复杂的逻辑：

    ```javascript
    class Animation {
      #element
      #startTime

      constructor(element) {
        this.#element = element
      }

      start() {
        this.#startTime = Date.now()
        const update = () => {
          const progress = Date.now() - this.#startTime
          // 闭包访问 #startTime
          this.#element.style.opacity = progress / 1000
          if (progress < 1000) requestAnimationFrame(update)
        }
        update()
      }
    }
    ```

- 总结
  - **闭包** 是 JavaScript 的函数式特性，适合轻量封装、兼容旧代码或函数式场景。
  - **类** 是面向对象的标准工具，适合复杂结构、继承和现代工程化开发。
  - **现代趋势**：随着 ES6+ 的普及，类逐渐成为主流，但闭包仍不可替代。选择时需权衡需求：**是否需要继承？是否需要兼容性？代码风格是函数式还是面向对象？**
  - 实际开发中，两者可以结合使用，充分发挥 JavaScript 的多范式优势。
